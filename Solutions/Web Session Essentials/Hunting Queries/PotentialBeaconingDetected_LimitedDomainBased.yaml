id: 8ece8108-7bf7-4571-8f32-ebfd92a6b1ad
name: Beaconing traffic based on common user agents visiting limited number of domains (ASIM Web Session)
description: |
  'This query searches web proxy logs for a specific type of beaconing behavior by joining a number of sources together: 
  - Traffic by actual web browsers - by looking at traffic generated by a UserAgent that looks like a browser and is used by multiple users
  to visit a large number of domains.
  - Users that make requests using one of these actual browsers, but only to a small set of domains, none of which are common domains.
  - The traffic is beacon-like; meaning that it occurs during many different hours of the day (i.e. periodic).'
tags:
  - Schema: WebSession
    SchemaVersion: 0.2.6
requiredDataConnectors: []
tactics:
  - CommandAndControl
relevantTechniques:
  - T1071.001
query: |
  let timeframe = 1d; // Timeframe during which to search for beaconing behavior.
  let lookback = 7d; // lookback period to find if browser was used for other domains by user.
  let min_requests = 50; // Minimum number of requests to consider it beacon traffic.
  let min_hours=8; // Minimum number of different hours during which connections were made to consider it beacon traffic.
  let trusted_user_count=10; // If visited by these many users a domain is considered 'trusted'.
  let Total_Visited_Sites=3; // Number of different sites visited using this user-agent.
  // Client-specific query to obtain 'browser-like' traffic from proxy logs.
  let BrowserTraffic = materialize (
  _Im_WebSession(starttime=ago(timeframe))
  | project  TimeGenerated, DstHostname, HttpUserAgent, SrcIpAddr, DstIpAddr
  | where ipv4_is_private(DstIpAddr) == false // Take only those requests that are going to internet
  | where HttpUserAgent has_any ("Mozilla","Gecko")
  );
  let CommonDomains = BrowserTraffic
  | summarize source_count=dcount(SrcIpAddr) by DstHostname
  | where source_count > trusted_user_count
  | project DstHostname; // These are list of common domains that we will filter out.
  let CommonUA = BrowserTraffic
  | summarize source_count=dcount(SrcIpAddr), dhost_count=dcount(DstHostname) by HttpUserAgent
  | where source_count >trusted_user_count and dhost_count > 100 // Normal browsers are used by many people visiting many different sites.
  | project HttpUserAgent;
  // Some users only use the browsers to visit a very limited set of sites.
  // These are considered suspicious, since they might be an attacker masquerading a beacon as a legitimate browser.
  let SuspiciousClients = BrowserTraffic
  | where HttpUserAgent in (CommonUA)
  | summarize Destination_Hosts = make_set(DstHostname), request_count=count() by HttpUserAgent, SrcIpAddr
  | where array_length( Destination_Hosts) <=Total_Visited_Sites and request_count >= min_requests
  | project HttpUserAgent, SrcIpAddr, Destination_Hosts;
  // Just reporting on suspicious browsers gives too many false positives.
  // For example, users that have the browser open on the login screen of 1 specific application.
  // In the suspicious browsers we can search for 'beacon-like' behavior.
  // Get all browser traffic by the suspicious browsers.
  let PotentialBeaconingTraffic=SuspiciousClients
  | join kind=inner (BrowserTraffic) on HttpUserAgent, SrcIpAddr
  // Find beaconing-like traffic - i.e. contacting the same host in many different hours.
  | summarize hour_count=dcount(bin(TimeGenerated,1h)), Destination_Hosts=take_any(Destination_Hosts), request_count=count() by HttpUserAgent, SrcIpAddr, DstHostname
  | where hour_count >=min_hours and request_count >= min_requests
  // Remove common domains i.e. visited by atleast trusted_user_count number of users.
  | join kind=leftanti CommonDomains on DstHostname // leftanti=> Returns all the records from the left side that don't have matches from the right
  | summarize RareHosts=make_set(DstHostname), TotalRequestCount=sum(request_count), BrowserHosts=take_any(Destination_Hosts) by HttpUserAgent, SrcIpAddr
  // Remove browsers that visit any common domains.
  | where array_length(RareHosts) == array_length(BrowserHosts);
  // Look back for X days to see if the browser was not used to visit more hosts.
  // This is to get rid of someone that started up the browser a long time ago, and left only a single tab open
  PotentialBeaconingTraffic
  | join kind=inner (_Im_WebSession(starttime=lookback)
  | project  TimeGenerated, DstHostname, HttpUserAgent, SrcIpAddr, DstIpAddr
  | where ipv4_is_private(DstIpAddr) == false // Take only those requests that are going to internet
  | where HttpUserAgent has_any ("Mozilla","Gecko")
  ) on SrcIpAddr, HttpUserAgent
  | summarize RareHosts=take_any(RareHosts),BrowserHosts1d=take_any(BrowserHosts),BrowserHostsLookback=make_set(DstHostname) by SrcIpAddr, HttpUserAgent
  | where array_length(RareHosts) == array_length(BrowserHostsLookback)
  | extend IP_0_Address = SrcIpAddr
entityMappings:
  - entityType: IP
    fieldMappings:
      - identifier: Address
        columnName: SrcIpAddr
version: 1.0.0