id: 43cb0347-bdcc-4e83-af5a-cebbd03971d8
name: Anomalous Azure Operation Hunting Model
description: |
  'This query can be used during threat hunts to identify a range of different Azure Operation anomalies.
  The query is heavily commented inline to explain operation. Anomalies covered are: New Caller, New Caller IP,
  New Caller IP Range, Anomalous operation based on Jaccard index. By default this query is configured to detect
  anomalous Run Command operations. The operation and resource type to perform anomaly detection can be configured 
  at the top of the query along with the detection window parameters'
requiredDataConnectors:
  - connectorId: AzureActivity
    dataTypes:
      - AzureActivity
tactics:
  - LateralMovement
  - CredentialAccess
relevantTechniques:
  - T1570
  - T1078.004
query: |
  // When the detection window will begin
  let startDetectDate = 3d;
  // When the detection window will end (now)
  let endDetectDate = 0d;
  // When to start collecting data, includingg model data (30 day sample)
  let startDate = startDetectDate + 30d;
  // Operation to monitor, in this case Run Command
  let monitoredOps = dynamic(['microsoft.compute/virtualmachines/runcommand/action']);
  // The resource type to monitor, in this case virtual machines
  let monitoredResource = pack_array('microsoft.compute/virtualmachines');
  // This function describes relationships between two values by calculating probabilities and related metrics.
  // For example, taking a user and resource type in Azure Activity logs. Intuitively, if probability (or related metric) of seeing specific user 
  // working on a specific resource type is low, yet they are doing it, this is anomalous.
  // One useful metric is Jaccard Similarity Index, defined as ratio between intersection and union probabilities. 
  // It is scaled between [0, 1]. When close to 0 - this means that the two values tend to stay apart. When close to 1 - they tend to be seen together.
  // An additional useful metric is Lift, defined as ratio between conditional probability and regular probability. 
  // When the Lift of two values is close to 1, it means they appear together as though they are independent. When it is much larger than 1, 
  // it means they appear together more than expected when assuming independence. When it is close to 0, it means the values appear much less 
  // than expected. Thus, when Jaccard index or Lift of specific {user, resourceType} pair are below threshold, it indicates anomalous 
  // (and thus potentially suspicious) behavior.
  let pair_probabilities_fl = (tbl:(*), A_col:string, B_col:string, scope_col:string)
  {
  let T = (tbl | extend _A = column_ifexists(A_col, ''), _B = column_ifexists(B_col, ''), _scope = column_ifexists(scope_col, ''));
  let countOnScope = T | summarize countAllOnScope = count() by _scope;
  let probAB = T | summarize countAB = count() by _A, _B, _scope | join kind = leftouter (countOnScope) on _scope | extend P_AB = todouble(countAB)/countAllOnScope;
  let probA  = probAB | summarize countA = sum(countAB), countAllOnScope = max(countAllOnScope) by _A, _scope | extend P_A = todouble(countA)/countAllOnScope;
  let probB  = probAB | summarize countB = sum(countAB), countAllOnScope = max(countAllOnScope) by _B, _scope | extend P_B = todouble(countB)/countAllOnScope;
      probAB
      | join kind = leftouter (probA) on _A, _scope           // probability for each value of A
      | join kind = leftouter (probB) on _B, _scope           // probability for each value of B
      | extend P_AUB = P_A + P_B - P_AB                       // union probability
             , P_AIB = P_AB/P_B                               // conditional probability of A on B
             , P_BIA = P_AB/P_A                               // conditional probability of B on A
      | extend Lift_AB = P_AB/(P_A * P_B)                     // lift metric
             , Jaccard_AB = P_AB/P_AUB                        // Jaccard similarity index
      | project _A, _B, _scope, floor(P_A, 0.00001), floor(P_B, 0.00001), floor(P_AB, 0.00001), floor(P_AUB, 0.00001), floor(P_AIB, 0.00001)
      , floor(P_BIA, 0.00001), floor(Lift_AB, 0.00001), floor(Jaccard_AB, 0.00001)
      | sort by _scope, _A, _B
  };
  // Prepare Azure Activity data for processing 
  let eventsTable = materialize (
  AzureActivity
  // Time window to collect activity
  | where TimeGenerated between (ago(startDate) .. ago(endDetectDate))
  // Only collect instances where the request Succeeded
  | where ActivityStatusValue has_any ('Success', 'Succeeded')
  // Process subscription ID and resource ID to support new and old connector schema
  | extend SubscriptionId = iff(isempty(_SubscriptionId), SubscriptionId, _SubscriptionId)
  | extend ResourceId = iff(isempty(_ResourceId), ResourceId, _ResourceId)
  // Process operations name and resource ID
  | extend splitOp = split(OperationNameValue, '/')
  | extend splitRes = split(ResourceId, '/')
  // Limit to actions with a caller IP
  | where isnotempty(CallerIpAddress)
  | project TimeGenerated , subscriptionId=SubscriptionId
              , ResourceProvider
              , ResourceName = tolower(tostring(splitRes[-1]))
              , OperationNameValue = tolower(OperationNameValue)
              , timeSlice = floor(TimeGenerated, 1d)
              , clientIp = tostring(CallerIpAddress)
              , Caller
              , isMonitoredOp = iff(OperationNameValue has_any (monitoredOps), 1, 0)
              , isMonitoredResource = iff(OperationNameValue has_any (monitoredResource), 1, 0)
              , CorrelationId
  | extend clientIpMask = format_ipv4_mask(clientIp, 16)
  );
  // Generate model data by aggregating over training window by subscription, caller and IP. We calculate the dates 
  // that the entity was first seen on subscription ('firstSeen'), performing monitored operation ('firstSeenOnMonOp') 
  // and working on the monitored resource ('firstSeenOnMonRes').
  let modelData =  (
  eventsTable
  | where TimeGenerated < ago(startDetectDate) and isnotempty(Caller) and isnotempty(subscriptionId)
  | summarize countEvents = count(), countMonRes = countif(isMonitoredResource == 1), counMonOp = countif(isMonitoredOp == 1)
      , firstSeen = min(timeSlice), firstSeenOnMonRes = minif(timeSlice, isMonitoredResource == 1), firstSeenOnMonOp = minif(timeSlice, isMonitoredOp == 1)
      by subscriptionId, Caller, clientIpMask
  );
  // Invoke pair_probabilities_fl (described above) over the processed Azure Activity data for {Caller, isMonitoredResource} pairs for each 
  // subscription. Caller identifies the user, and isMonitoredResource is a flag for monitored resource type. We calculate the metrics for 
  // each user to do any work on relevant resource type at training window. We filter the results by relevant resource 
  // (isMonitoredResource == 1) for later usage.
  let monOpProbs = materialize (
  eventsTable
  | where TimeGenerated < ago(startDetectDate) and isnotempty(Caller) and isnotempty(subscriptionId)
  | invoke pair_probabilities_fl('Caller', 'isMonitoredResource','subscriptionId')
  | where _B == 1
  | sort by P_AIB desc
  | extend rankOnMonRes = row_rank(P_AIB), sumBiggerCondProbs = row_cumsum(P_AIB) - P_AIB
  | extend avgBiggerCondProbs = floor(iff(rankOnMonRes > 1, sumBiggerCondProbs/(rankOnMonRes-1), max_of(0.0, prev(sumBiggerCondProbs))), 0.00001)
  | project-away sumBiggerCondProbs
  );
  // Now join the original data, the model data and pair_probabilities_fl data
  eventsTable
  | where TimeGenerated between (ago(startDetectDate) .. ago(endDetectDate))
  // Join with modelData on subscriptionId and Caller, to get firstSeen dates (general, monitored resource and monitored operation) for this Caller on subscription
  | join kind = leftouter (modelData | summarize countEventsPrincOnSub = sum(countEvents), countEventsMonResPrincOnSub = sum(countMonRes),  countEventsMonOpPrincOnSub = sum(counMonOp)
      , firstSeenPrincOnSubs = min(firstSeen), firstSeenMonResPrincOnSubs = min(firstSeenOnMonRes), firstSeenMonOpPrincOnSubs = min(firstSeenOnMonOp) by subscriptionId, Caller) 
          on subscriptionId, Caller
  // Join with modelData on subscriptionId and IpMask, to get firstSeen dates (general, monitored resource and monitored operation) for this IpMask on subscription
  | join kind = leftouter (modelData | summarize countEventsIpMaskOnSub = sum(countEvents), countEventsMonResIpMaskOnSub = sum(countMonRes),  countEventsMonOpIpMaskOnSub = sum(counMonOp)
      , firstSeenIpMaskOnSubs = min(firstSeen), firstSeenMonResIpMaskOnSubs = min(firstSeenOnMonRes), firstSeenMonOpIpMaskOnSubs = min(firstSeenOnMonOp) by subscriptionId, clientIpMask) 
          on subscriptionId, clientIpMask
  // Join with modelData on subscriptionId, to get firstSeen dates (general, monitored resource and monitored operation) for this subscription in general (all users)
  | join kind = leftouter (modelData | summarize countEventsOnSub = sum(countEvents), countEventsMonResOnSub = sum(countMonRes),  countEventsMonOpOnSub = sum(counMonOp)
      , firstSeenOnSubs = min(firstSeen), firstSeenMonResOnSubs = min(firstSeenOnMonRes), firstSeenMonOpOnSubs = min(firstSeenOnMonOp)
      , countCallersOnSubs = dcount(Caller), countIpMasksOnSubs = dcount(clientIpMask) by subscriptionId)
          on subscriptionId        
  | project-away subscriptionId1, Caller1, subscriptionId2
  // Calculate the number of days the user has been active in the subscription
  | extend daysOnSubs = datetime_diff('day', timeSlice, firstSeenOnSubs)
  // Calculate the average number of monitored operations performed on the subscription, representing the expected baseline of operations
  | extend avgMonOpOnSubs = floor(1.0*countEventsMonOpOnSub/daysOnSubs, 0.01), avgMonResOnSubs = floor(1.0*countEventsMonResOnSub/daysOnSubs, 0.01)
  // Join with monOpProbs on subscriptionId and Caller to get probabilities for ths user to work on monitored resourceType
  | join kind = leftouter(monOpProbs) on $left.subscriptionId == $right._scope, $left.Caller == $right._A
  | project-away _A, _B, _scope
  | sort by subscriptionId asc, TimeGenerated asc
  | extend rnOnSubs = row_number(1, subscriptionId != prev(subscriptionId))
  | sort by subscriptionId asc, Caller asc, TimeGenerated asc
  | extend rnOnCallerSubs = row_number(1, (subscriptionId != prev(subscriptionId) and (Caller != prev(Caller))))
  //// // Anomaly scenarios
  // Indicates that Caller wasn't seen on subscription during training, since joining with model data on that caller brought no results.
  // Seeing a previously unseen Caller performing a high-riks operation is suspicious.
  | extend newCaller = iff(isempty(firstSeenPrincOnSubs), 1, 0)
  // Indicates that Caller didn't perform operations on monitored resource type during training.
  // Seeing a Caller who previously didn't work on this resource performing a high-risk operation is suspicious.
      , newCallerOnMonRes = iff(isempty(firstSeenMonResPrincOnSubs), 1, 0)
  // Indicates that IpMask wasn't seen on subscription during training.
  // Seeing a previously unseen IpMask performing a high-riks operation is suspicious.
      , newIpMask = iff(isempty(firstSeenIpMaskOnSubs), 1, 0)
  // Indicates that IpMask didn't perform operations on monitored resource type during training.
  // Seeing an IpMask who previously didn't work on this resource performing a high-risk operation is suspicious. 
      , newIpMaskOnMonRes = iff(isempty(firstSeenMonResIpMaskOnSubs), 1, 0)
  // Indicates that monitored operation wasn't performed at all on subscription during training.
  // Seeing a high-risk operation performed for the first time on subscription is suspicious.
      , newMonOpOnSubs = iff(isempty(firstSeenMonResOnSubs), 1, 0)
  // Indicates that operation was performed on monitored resource type by user who usually doesn't work on monitored resource type.
  // This is suspicious, since it might indicate that this user that doesn't have a legitimate reason to do any operations
  // on this resource type, in particular a high-value operation as the monitored one.
  // We look for low Jaccard Index or Lift values calculated over training period, which indicate that any activity on monitored resource type is anomalous for this user.
  // Thus, actual execution of high-risk operation on monitored resource in detection window is unexpected and thus suspicious.
  // By setting a lower value for anomalyProbThreshold, we can look for more significant anomalies.
      , anomCallerMonRes = iff(((Jaccard_AB <= 0.1) or (P_AIB <= 0.1)), 1, 0)
  | project TimeGenerated, subscriptionId,  ResourceProvider, ResourceName, OperationNameValue, Caller, CorrelationId, ClientIP=clientIp, ActiveDaysOnSub=daysOnSubs, avgMonOpOnSubs, newCaller, newCallerOnMonRes, newIpMask, newIpMaskOnMonRes, newMonOpOnSubs, anomCallerMonRes, isMonitoredOp, isMonitoredResource
  | order by TimeGenerated
  | where isMonitoredOp == 1
  // Optional - focus only on monitored operations or monitored resource in detection window
  | where isMonitoredOp == 1
  //| where isMonitoredResource == 1