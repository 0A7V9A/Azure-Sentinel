{
  "$schema": "https://schema.management.azure.com/schemas/2019-08-01/deploymentTemplate.json#",
  "contentVersion": "1.0.0.0",
  "parameters": {
    "Workspace": {
      "type": "string",
      "metadata": {
        "description": "The Microsoft Sentinel workspace into which the function will be deployed. Has to be in the selected Resource Group."
      }
    },
    "WorkspaceRegion": {
      "type": "string",
      "defaultValue": "[resourceGroup().location]",
      "metadata": {
        "description": "The region of the selected workspace. The default value will use the Region selection above."
      }
    }
  },
  "resources": [
    {
      "type": "Microsoft.OperationalInsights/workspaces",
      "apiVersion": "2017-03-15-preview",
      "name": "[parameters('Workspace')]",
      "location": "[parameters('WorkspaceRegion')]",
      "resources": [
        {
          "type": "savedSearches",
          "apiVersion": "2020-08-01",
          "name": "vimNetworkSessionCiscoASA",
          "dependsOn": [
            "[concat('Microsoft.OperationalInsights/workspaces/', parameters('Workspace'))]"
          ],
          "properties": {
            "etag": "*",
            "displayName": "Network Session ASIM parser for Cisco ASA",
            "category": "ASIM",
            "FunctionAlias": "vimNetworkSessionCiscoASA",
            "query": "let EventResultMapping = datatable (Reason:string, DeviceAction:string, EventResult:string, EventResultDetails:string, EventOriginalResultDetails:string)  [\n  'Conn-timeout', '', 'Success', 'Timeout', 'The connection ended when a flow is closed because of the expiration of its inactivity timer.',\n  'Deny Terminate', 'Deny', 'Failure', 'Terminated', 'Flow was terminated by application inspection.',\n  'Failover primary closed', '', 'Success', 'Failover', 'The standby unit in a failover pair deleted a connection because of a message received from the active unit.',\n  'FIN Timeout', '', 'Success', 'Timeout', 'Force termination after 10 minutes awaiting the last ACK or after half-closed timeout.',  \n  'Flow closed by inspection', 'Deny', 'Failure', 'Terminated', 'Flow was terminated by the inspection feature.',\n  'Flow terminated by IPS', 'Deny', 'Failure', 'Terminated', 'Flow was terminated by IPS.',\n  'Flow reset by IPS', 'Reset', 'Failure', 'Terminated', 'Flow was reset by IPS.',     \n  'Flow terminated by TCP Intercept', 'TCP Intercept', 'Failure', 'Terminated', 'Flow was terminated by TCP Intercept.',\n  'Flow timed out', '', 'Success', 'Timeout', 'Flow has timed out.',\n  'Flow timed out with reset', 'Reset', 'Failure', 'Timeout', 'Flow has timed out, but was reset.',\n  'Free the flow created as result of packet injection', '', 'Success', 'Simulation', 'The connection was built because the packet tracer feature sent a simulated packet through the Secure Firewall ASA.',\n  'Invalid SYN', '', 'Failure', 'Invalid TCP', 'The SYN packet was not valid.',\n  'IPS fail-close', 'Deny', 'Failure', 'Terminated', 'Flow was terminated because the IPS card is down.',\n  'No interfaces associated with zone', '', 'Failure', 'Routing issue', 'Flows were torn down after the \u201cno nameif\u201d or \u201cno zone-member\u201d leaves a zone with no interface members.',\n  'No valid adjacency', 'Drop', 'Failure', 'Routing issue', 'This counter is incremented when the Secure Firewall ASA tried to obtain an adjacency and could not obtain the MAC address for the next hop. The packet is dropped.',\n  'Pinhole Timeout', '', 'Failure', 'Timeout', 'The counter is incremented to report that the Secure Firewall ASA opened a secondary flow, but no packets passed through this flow within the timeout interval, and so it was removed. An example of a secondary flow is the FTP data channel that is created after successful negotiation on the FTP control channel.',\n  'Probe maximum retries of retransmission exceeded', '', 'Failure', 'Maximum Retry', 'The connection was torn down because the TCP packet exceeded maximum probe retries of retransmission.',\n  'Probe maximum retransmission time elapsed', '', 'Failure', 'Maximum Retry', 'The connection was torn down because the maximum probing time for TCP packet had elapsed.',\n  'Probe received RST', '', 'Failure', 'Reset', 'The connection was torn down because probe connection received RST from server.',\n  'Probe received FIN', '', 'Success', '', 'The connection was torn down because probe connection received FIN from server and complete FIN closure process was completed.',\n  'Probe completed', '', 'Success', '', 'The probe connection was successful.', \n  'Route change', '', 'Success', '', 'When the Secure Firewall ASA adds a lower cost (better metric) route, packets arriving that match the new route cause their existing connection to be torn down after the user-configured timeout (floating-conn) value. Subsequent packets rebuild the connection out of the interface with the better metric. To prevent the addition of lower cost routes from affecting active flows, you can set the floating-conn configuration timeout value to 0:0:0.', \n  'SYN Control', '', 'Failure', 'Invalid TCP', 'A back channel initiation occurred from the wrong side.',\n  'SYN Timeout', '', 'Failure', 'Timeout', 'Force termination after 30 seconds, awaiting three-way handshake completion.',\n  'TCP bad retransmission', '', 'Success', 'Invalid TCP', 'The connection was terminated because of a bad TCP retransmission.',\n  'TCP FINs', '', 'Success', '', 'A normal close-down sequence occurred.',\n  'TCP Invalid SYN', '', 'Failure', 'Invalid TCP', 'Invalid TCP SYN packet.',              \n  'TCP Reset-APPLIANCE', '', 'Failure', 'Reset', 'The flow is closed when a TCP reset is generated by the Secure Firewall ASA.',\n  'TCP Reset-I', '', 'Failure', 'Reset', 'Reset was from the inside.',\n  'TCP Reset-O', '', 'Failure', 'Reset', 'Reset was from the outside.',\n  'TCP segment partial overlap', '', 'Failure', 'Invalid TCP', 'A partially overlapping segment was detected.',\n  'TCP unexpected window size variation', '', 'Failure', 'Invalid TCP', 'A connection was terminated due to variation in the TCP window size.',  \n  'Tunnel has been torn down', '', 'Failure', 'Invalid Tunnel', 'Flow was terminated because the tunnel is down.',\n  'Unknown', 'Deny', 'Failure', 'Terminated', 'An authorization was denied by a URL filter.', 'Unauth Deny', '', 'Failure', 'Unknown', 'An unknown error has occurred.',               \n  'Xlate Clear', '', '', '', 'A command line was removed.',              \n];\n    let NWParser = (\n          starttime:datetime=datetime(null), \n          endtime:datetime=datetime(null),\n          srcipaddr_has_any_prefix:dynamic=dynamic([]), \n          dstipaddr_has_any_prefix:dynamic=dynamic([]), \n          ipaddr_has_any_prefix:dynamic=dynamic([]),\n          dstportnumber:int=int(null), \n          hostname_has_any:dynamic=dynamic([]), \n          dvcaction:dynamic=dynamic([]), \n          eventresult:string='*', \n          disabled:bool=false)\n      { \nlet src_or_any = set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); \nlet dst_or_any = set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix);\n    let allLogs = CommonSecurityLog\n    | where not(disabled)\n    | where (isnull(starttime) or TimeGenerated >= starttime) and (isnull(endtime) or TimeGenerated <= endtime)\n    | where DeviceVendor == \"Cisco\" and DeviceProduct == \"ASA\"\n    | where (isnull(dstportnumber) or (DestinationPort == dstportnumber)) or Message has tostring(dstportnumber)\n    | extend temp_isSrcMatch=has_any_ipv4_prefix(SourceIP,src_or_any), \n                      temp_isDstMatch=has_any_ipv4_prefix(DestinationIP,dst_or_any)\n    | extend ASimMatchingIpAddr = case(\n                                      array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, \"-\", // match not requested\n                                      (temp_isSrcMatch and temp_isDstMatch), \"Both\", // has to be checked before the individual \n                                      temp_isSrcMatch, \"SrcIpAddr\",\n                                      temp_isDstMatch, \"DstIpAddr\",\n                                      \"No match\"\n                                  )\n    | where ASimMatchingIpAddr != \"No match\"\n    | where ((array_length(dvcaction) == 0) or SimplifiedDeviceAction has_any (dvcaction));\n    let all_106001_alike = allLogs\n    | where DeviceEventClassID in (\"106001\", \"106006\", \"106015\", \"106016\", \"106021\", \"106022\") \n    | parse Message with * \" interface \" DstInterfaceName;\n    let all_106010_alike = allLogs\n    | where DeviceEventClassID in (\"106010\", \"106014\")\n    | parse Message with * \" src \"  SrcInterfaceName \":\" * \" dst \" DstInterfaceName \":\" *;\n    let all_106018 = allLogs\n    | where DeviceEventClassID == \"106018\"\n    | parse Message with * \"list \" NetworkRuleName:string \" \" *;\n    let all_106023 = allLogs\n    | where DeviceEventClassID == \"106023\" and not(Message contains \"protocol 41\") and isnotempty(SourceIP)\n    | parse Message with * \" src \"  SrcInterfaceName \":\" * \" dst \" DstInterfaceName \":\" * ' by access-group \"' NetworkRuleName '\" '  *;\n    let all_106023_unparsed = allLogs\n    | where DeviceEventClassID == \"106023\" and isempty(SourceIP) and not(Message contains \"protocol 41\")\n    | where Message has tostring(dstportnumber)\n    | extend parsedData = extract_all(@'%ASA-\\d-\\d+:\\s*(\\w+)\\s+(\\w+)\\s+src\\s+(\\S+):(\\d+.\\d+.\\d+.\\d+)\\/(\\d+)\\s*(\\(\\S+\\)|\\S+)*\\s+dst\\s+(\\S+):(\\d+.\\d+.\\d+.\\d+)\\/(\\d+)\\s*([(\\S+\\s+)]+|\\S+)*\\s*by\\s+access-group\\s*\"(\\S+)\"',Message)[0]\n    | extend \n            DeviceAction = coalesce(DeviceAction, tostring(parsedData[0])),\n            Protocol = coalesce(Protocol, tostring(parsedData[1])),\n            SrcInterfaceName = tostring(parsedData[2]),\n            SrcIpAddr = coalesce(SourceIP, tostring(parsedData[3])),\n            SrcPortNumber = coalesce(SourcePort, toint(parsedData[4])),\n            SrcUsername = replace_string(replace_string(tostring(parsedData[5]), \")\", \"\"), \"(\", \"\"),\n            DstInterfaceName = tostring(parsedData[6]),\n            DstIpAddr = coalesce(DestinationIP, tostring(parsedData[7])),\n            DstPortNumber = coalesce(DestinationPort, toint(parsedData[8])),\n            DstUsername = replace_string(replace_string(tostring(parsedData[9]), \")\", \"\"), \"(\", \"\"),\n            NetworkRuleName = tostring(parsedData[10])\n    | where (isnull(dstportnumber) or (DstPortNumber == dstportnumber))\n    | extend temp_isSrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any), \n                temp_isDstMatch=has_any_ipv4_prefix(DstIpAddr,dst_or_any)\n    | extend ASimMatchingIpAddr = case(\n                              array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, \"-\", // match not requested\n                              (temp_isSrcMatch and temp_isDstMatch), \"Both\", // has to be checked before the individual \n                              temp_isSrcMatch, \"SrcIpAddr\",\n                              temp_isDstMatch, \"DstIpAddr\",\n                              \"No match\"\n                          )\n    | where ASimMatchingIpAddr != \"No match\"\n    | where ((array_length(dvcaction) == 0) or DeviceAction has_any (dvcaction))\n    | extend \n            SrcUsernameType = iif(isnotempty(SrcUsername),\"Windows\",\"\"),\n            DstUsernameType = iif(isnotempty(DstUsername),\"Windows\",\"\"),\n            SimplifiedDeviceAction = DeviceAction\n    | project-away parsedData;\n    let all_106023_41 = allLogs\n    | where DeviceEventClassID == \"106023\" and Message contains \"protocol 41\"\n    | parse Message with * \": \" Action \" \" ProtocolFromLog \" src \" SrcInterfaceName \":\" SrcIpAddr \" dst \" DstInterfaceName \":\" DstIpAddr ' by access-group ' NetworkRuleName ' '  *\n    | extend temp_isSrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any), \n                temp_isDstMatch=has_any_ipv4_prefix(DstIpAddr,dst_or_any)\n    | extend ASimMatchingIpAddr = case(\n                              array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, \"-\", // match not requested\n                              (temp_isSrcMatch and temp_isDstMatch), \"Both\", // has to be checked before the individual \n                              temp_isSrcMatch, \"SrcIpAddr\",\n                              temp_isDstMatch, \"DstIpAddr\",\n                              \"No match\"\n                          )\n    | where ASimMatchingIpAddr != \"No match\"\n    | where ((array_length(dvcaction) == 0) or Action has_any (dvcaction))\n    | extend Protocol = case(isnotempty(Protocol), Protocol,\n                            ProtocolFromLog endswith \"41\", \"41\",\n                            \"\"),\n            NetworkRuleName = replace_string(NetworkRuleName,'\"',''),\n            DeviceAction = trim_start(@\"\\s*\",Action),\n            SimplifiedDeviceAction = trim_start(@\"\\s*\",Action)\n    | project-away ProtocolFromLog, Action;\n    let all_302013_302015 = allLogs\n    | where DeviceEventClassID in (\"302013\",\"302015\")      \n    | where Message has tostring(dstportnumber)\n    | parse Message with * \":  \" DeviceAction \" \" NetworkDirection \" \" Protocol \" connection \" NetworkSessionId \" for \" SrcInterfaceName \":\" SrcIpAddr \"/\" SrcPortNumber:int \" (\" SrcNatIpAddr \"/\" SrcNatPortNumber:int \")\" SrcUsername \"to \" DstInterfaceName \":\" DstIpAddr \"/\" DstPortNumber:int \" (\" DstNatIpAddr \"/\" DstNatPortNumber:int \")\" DstUsername\n    | where (isnull(dstportnumber) or (DstPortNumber == dstportnumber))\n    | extend temp_isSrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any), \n                temp_isDstMatch=has_any_ipv4_prefix(DstIpAddr,dst_or_any)\n    | extend ASimMatchingIpAddr = case(\n                              array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, \"-\", // match not requested\n                              (temp_isSrcMatch and temp_isDstMatch), \"Both\", // has to be checked before the individual \n                              temp_isSrcMatch, \"SrcIpAddr\",\n                              temp_isDstMatch, \"DstIpAddr\",\n                              \"No match\"\n                          )\n    | where ASimMatchingIpAddr != \"No match\"\n    | where ((array_length(dvcaction) == 0) or DeviceAction has_any (dvcaction))\n    | extend SrcUsername = replace_string(replace_string(SrcUsername,\"(\",\"\"),\")\",\"\"),\n             DstUsername = replace_string(replace_string(DstUsername,\"(\",\"\"),\")\",\"\"),\n             NetworkDirection = case(NetworkDirection == \"inbound\", \"Inbound\",\n                                     NetworkDirection == \"outbound\", \"Outbound\",\n                                     NetworkDirection)\n    | extend \n            SrcUsernameType = iif(isnotempty(SrcUsername),\"Windows\",\"\"),\n            DstUsernameType = iif(isnotempty(DstUsername),\"Windows\",\"\"),\n            SimplifiedDeviceAction = DeviceAction,\n            SessionId = NetworkSessionId;\n    let all_302014_302016 = allLogs\n    | where DeviceEventClassID in (\"302014\", \"302016\")\n    | where Message has tostring(dstportnumber)\n    | extend parsedData = extract_all(@\"%ASA-\\d-\\d+:\\s*(\\w+)\\s+(\\w+)\\s+connection\\s+(\\d+)\\s+for\\s+(\\S+):(\\d+.\\d+.\\d+.\\d+)\\/(\\d+)\\s*(\\(\\S+\\)|\\S+)*\\s+to\\s+(\\S+):(\\d+.\\d+.\\d+.\\d+)\\/(\\d+)\\s*([(\\S+\\s+)]+|\\S+)*\\s*[Dd]uration\\s+(\\d+:\\d+:\\d+)\\s+bytes\\s+(\\d+)\\s*([\\S+\\s*]+)*\",Message)[0]\n  | extend reasonParsed = extract_all(@\"$|\\((\\S+)\\)|([\\S+\\s*]+)\\s+from+\\s+\\S+\\s+(\\(\\S+\\)|\\S+)$|([\\S+\\s*]+)\\s+from+\\s+\\S+$|([\\S+\\s*]+)$\",tostring(parsedData[13]))[0]\n    | extend \n            DeviceAction = coalesce(DeviceAction, tostring(parsedData[0])),\n            Protocol = coalesce(Protocol, tostring(parsedData[1])),\n            NetworkSessionId = tostring(parsedData[2]),\n            SrcInterfaceName = tostring(parsedData[3]),\n            SrcIpAddr = coalesce(SourceIP, tostring(parsedData[4])),\n            SrcPortNumber = coalesce(SourcePort, toint(parsedData[5])),\n            SrcUsername = replace_string(replace_string(tostring(parsedData[6]), \")\", \"\"), \"(\", \"\"),\n            DstInterfaceName = tostring(parsedData[7]),\n            DstIpAddr = coalesce(DestinationIP, tostring(parsedData[8])),\n            DstPortNumber = coalesce(DestinationPort, toint(parsedData[9])),\n            DstUsername = coalesce(replace_string(replace_string(tostring(parsedData[10]), \")\", \"\"), \"(\", \"\"), tostring(reasonParsed[0]), replace_string(replace_string(tostring(reasonParsed[2]), \")\", \"\"), \"(\", \"\")),\n            NetworkDuration = toint(24 * 60 * totimespan(parsedData[11]) / time(1s)),\n            DstBytes = tolong(parsedData[12]),\n            Reason = coalesce(tostring(reasonParsed[1]), tostring(reasonParsed[3]), tostring(reasonParsed[4]))\n    | where (isnull(dstportnumber) or (DstPortNumber == dstportnumber))\n    | extend temp_isSrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any), \n                  temp_isDstMatch=has_any_ipv4_prefix(DstIpAddr,dst_or_any)\n    | extend ASimMatchingIpAddr = case(\n                                  array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, \"-\", // match not requested\n                                  (temp_isSrcMatch and temp_isDstMatch), \"Both\", // has to be checked before the individual \n                                  temp_isSrcMatch, \"SrcIpAddr\",\n                                  temp_isDstMatch, \"DstIpAddr\",\n                                  \"No match\"\n                              )\n    | where ASimMatchingIpAddr != \"No match\"\n    | where ((array_length(dvcaction) == 0) or DeviceAction has_any (dvcaction))\n    | lookup EventResultMapping on Reason\n    | where (eventresult == \"*\" or eventresult == EventResult) \n    | extend \n            SrcUsernameType = iif(isnotempty(SrcUsername),\"Windows\",\"\"),\n            DstUsernameType = iif(isnotempty(DstUsername),\"Windows\",\"\"),\n            SimplifiedDeviceAction = DeviceAction,\n            SessionId = NetworkSessionId,\n            EventOriginalResultDetails = iif(isnotempty(EventOriginalResultDetails), strcat(Reason, \" - \", EventOriginalResultDetails), EventOriginalResultDetails)\n    | project-away parsedData, reasonParsed, Reason;\n    let all_302020_302021 = allLogs\n    | where DeviceEventClassID in (\"302020\",\"302021\")\n    | extend SrcUsername = tostring(extract_all(@\"\\((\\S+)\\)\",Message)[0])      \n    | extend SrcUsernameType = iif(isnotempty(SrcUsername),\"Windows\",\"\");\n    let all_7_series = allLogs\n    | where DeviceEventClassID in (\"710002\",\"710003\",\"710004\",\"710005\")\n    | parse Message with * \" to \" DstInterfaceName \":\" *;\n    let remainingLogs = allLogs\n    | where DeviceEventClassID in (\"106002\", \"106007\", \"106012\", \"106013\", \"106017\", \"106020\", \"106100\");\n    let ExternalInterface = _ASIM_GetWatchlistRaw(\"NetworkAddresses\")\n                              | extend WatchlistItem = parse_json(WatchlistItem)\n                              | where WatchlistItem.Tags has \"External\"\n                              | distinct tostring(WatchlistItem[\"Range Name\"]);\n    union isfuzzy=true all_106001_alike, all_106010_alike, all_106018, all_106023, all_106023_unparsed, all_106023_41,  all_302013_302015, all_302014_302016, all_302020_302021, all_7_series, remainingLogs\n    | extend \n            EventStartTime = TimeGenerated,\n            EventEndTime = TimeGenerated,\n            EventVendor = \"Cisco\",\n            EventProduct = \"ASA\",\n            EventCount = toint(1),\n            EventType = \"NetworkSession\",\n            EventSchema = \"NetworkSession\",\n            EventSchemaVersion = \"0.2.3\",\n            EventProductVersion = DeviceVersion,\n            EventOriginalSubType = DeviceEventClassID,\n            EventSeverity = LogSeverity,\n            EventOriginalSeverity = OriginalLogSeverity,\n            DvcOriginalAction = DeviceAction,\n            DvcAction = case(SimplifiedDeviceAction in (\"Teardown\",\"Built\"), \"\",\n                            SimplifiedDeviceAction),\n            EventMessage = Message,\n            Dvc = Computer,\n            DstPortNumber = coalesce(DstPortNumber, DestinationPort),\n            SrcPortNumber = coalesce(SrcPortNumber, SourcePort),\n            DstIpAddr = coalesce(DstIpAddr, DestinationIP),\n            SrcIpAddr = coalesce(SrcIpAddr, SourceIP),\n            NetworkRuleName = coalesce(NetworkRuleName, DeviceCustomString2)\n    | extend \n            NetworkDirection = case(isnotempty(CommunicationDirection), CommunicationDirection,\n                                    DstInterfaceName in (ExternalInterface), \"Outbound\",\n                                    SrcInterfaceName in (ExternalInterface), \"Inbound\",\n                                    SrcInterfaceName !in (ExternalInterface) and DstInterfaceName !in (ExternalInterface), \"Local\",\n                                    \"\"),\n            NetworkProtocol = case(isnotempty(Protocol), toupper(Protocol),\n                                  toint(Protocol) == \"41\", \"IPv6\",\n                                  toint(Protocol) == \"47\", \"GRE\",\n                                  \"\"),\n            EventResult = case(isnotempty(EventResult), EventResult,\n                              DvcAction == \"Allow\", \"Success\",\n                              \"Failure\"),\n            Src = SrcIpAddr,\n            Dst = DstIpAddr,\n            Duration = NetworkDuration,\n            IpAddr = SrcIpAddr,\n            Rule = NetworkRuleName,\n            User = DstUsername\n    | where (eventresult == \"*\" or eventresult == EventResult) \n    | project-away Activity, AdditionalExtensions, ApplicationProtocol, CommunicationDirection, Computer, Destination*, Device*, EndTime, ExternalID, File*, Flex*, IndicatorThreatType, LogSeverity, Malicious*, Message, Old*, OriginalLogSeverity, Process*, Protocol, ReceiptTime, ReceivedBytes, Remote*, Report*, Request*, SentBytes, SimplifiedDeviceAction, Source*, StartTime, TenantId, ThreatConfidence, ThreatDescription, ThreatSeverity\n    };\n  NWParser (starttime, endtime, srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix, dstportnumber, hostname_has_any, dvcaction, eventresult, disabled)",
            "version": 1,
            "functionParameters": "starttime:datetime=datetime(null),endtime:datetime=datetime(null),srcipaddr_has_any_prefix:dynamic=dynamic([]),dstipaddr_has_any_prefix:dynamic=dynamic([]),ipaddr_has_any_prefix:dynamic=dynamic([]),dstportnumber:int=int(null),hostname_has_any:dynamic=dynamic([]),dvcaction:dynamic=dynamic([]),eventresult:string='*',disabled:bool=False"
          }
        }
      ]
    }
  ]
}