Parser:
  Title: Network Session ASIM parser for Cisco ASA
  Version: '1.0'
  LastUpdated: August 03, 2022
Product:
  Name: CiscoASA
Normalization:
  Schema: NetworkSession
  Version: '0.2.3'
References:
  - Title: ASIM Network Session Schema
    Link: https://aka.ms/ASimNetworkSessionDoc
  - Title: ASIM
    Link: https://aka.ms/AboutASIM
  - Title: Error code Description in Cisco ASA 
    Link: https://www.cisco.com/c/en/us/td/docs/security/asa/syslog/b_syslog.html
Description: |
  This ASIM parser supports normalizing commonly used Cisco ASA Error Code logs coming from CEF Data Connector to the ASIM Network Session normalized schema.
ParserName: ASimNetworkSessionCiscoASA
EquivalentBuiltInParser: _ASim_NetworkSession_CiscoASA
ParserParams:
  - Name: disabled
    Type: bool
    Default: false
ParserQuery: |
  let EventResultMapping = datatable (Reason:string, DeviceAction:string, EventResult:string, EventResultDetails:string, EventOriginalResultDetails:string)  [
    'Conn-timeout', '', 'Success', 'Timeout', 'The connection ended when a flow is closed because of the expiration of its inactivity timer.',
    'Deny Terminate', 'Deny', 'Failure', 'Terminated', 'Flow was terminated by application inspection.',
    'Failover primary closed', '', 'Success', 'Failover', 'The standby unit in a failover pair deleted a connection because of a message received from the active unit.',
    'FIN Timeout', '', 'Success', 'Timeout', 'Force termination after 10 minutes awaiting the last ACK or after half-closed timeout.',  
    'Flow closed by inspection', 'Deny', 'Failure', 'Terminated', 'Flow was terminated by the inspection feature.',
    'Flow terminated by IPS', 'Deny', 'Failure', 'Terminated', 'Flow was terminated by IPS.',
    'Flow reset by IPS', 'Reset', 'Failure', 'Terminated', 'Flow was reset by IPS.',     
    'Flow terminated by TCP Intercept', 'TCP Intercept', 'Failure', 'Terminated', 'Flow was terminated by TCP Intercept.',
    'Flow timed out', '', 'Success', 'Timeout', 'Flow has timed out.',
    'Flow timed out with reset', 'Reset', 'Failure', 'Timeout', 'Flow has timed out, but was reset.',
    'Free the flow created as result of packet injection', '', 'Success', 'Simulation', 'The connection was built because the packet tracer feature sent a simulated packet through the Secure Firewall ASA.',
    'Invalid SYN', '', 'Failure', 'Invalid TCP', 'The SYN packet was not valid.',
    'IPS fail-close', 'Deny', 'Failure', 'Terminated', 'Flow was terminated because the IPS card is down.',
    'No interfaces associated with zone', '', 'Failure', 'Routing issue', 'Flows were torn down after the “no nameif” or “no zone-member” leaves a zone with no interface members.',
    'No valid adjacency', 'Drop', 'Failure', 'Routing issue', 'This counter is incremented when the Secure Firewall ASA tried to obtain an adjacency and could not obtain the MAC address for the next hop. The packet is dropped.',
    'Pinhole Timeout', '', 'Failure', 'Timeout', 'The counter is incremented to report that the Secure Firewall ASA opened a secondary flow, but no packets passed through this flow within the timeout interval, and so it was removed. An example of a secondary flow is the FTP data channel that is created after successful negotiation on the FTP control channel.',
    'Probe maximum retries of retransmission exceeded', '', 'Failure', 'Maximum Retry', 'The connection was torn down because the TCP packet exceeded maximum probe retries of retransmission.',
    'Probe maximum retransmission time elapsed', '', 'Failure', 'Maximum Retry', 'The connection was torn down because the maximum probing time for TCP packet had elapsed.',
    'Probe received RST', '', 'Failure', 'Reset', 'The connection was torn down because probe connection received RST from server.',
    'Probe received FIN', '', 'Success', '', 'The connection was torn down because probe connection received FIN from server and complete FIN closure process was completed.',
    'Probe completed', '', 'Success', '', 'The probe connection was successful.', 
    'Route change', '', 'Success', '', 'When the Secure Firewall ASA adds a lower cost (better metric) route, packets arriving that match the new route cause their existing connection to be torn down after the user-configured timeout (floating-conn) value. Subsequent packets rebuild the connection out of the interface with the better metric. To prevent the addition of lower cost routes from affecting active flows, you can set the floating-conn configuration timeout value to 0:0:0.', 
    'SYN Control', '', 'Failure', 'Invalid TCP', 'A back channel initiation occurred from the wrong side.',
    'SYN Timeout', '', 'Failure', 'Timeout', 'Force termination after 30 seconds, awaiting three-way handshake completion.',
    'TCP bad retransmission', '', 'Success', 'Invalid TCP', 'The connection was terminated because of a bad TCP retransmission.',
    'TCP FINs', '', 'Success', '', 'A normal close-down sequence occurred.',
    'TCP Invalid SYN', '', 'Failure', 'Invalid TCP', 'Invalid TCP SYN packet.',              
    'TCP Reset-APPLIANCE', '', 'Failure', 'Reset', 'The flow is closed when a TCP reset is generated by the Secure Firewall ASA.',
    'TCP Reset-I', '', 'Failure', 'Reset', 'Reset was from the inside.',
    'TCP Reset-O', '', 'Failure', 'Reset', 'Reset was from the outside.',
    'TCP segment partial overlap', '', 'Failure', 'Invalid TCP', 'A partially overlapping segment was detected.',
    'TCP unexpected window size variation', '', 'Failure', 'Invalid TCP', 'A connection was terminated due to variation in the TCP window size.',  
    'Tunnel has been torn down', '', 'Failure', 'Invalid Tunnel', 'Flow was terminated because the tunnel is down.',
    'Unknown', 'Deny', 'Failure', 'Terminated', 'An authorization was denied by a URL filter.', 'Unauth Deny', '', 'Failure', 'Unknown', 'An unknown error has occurred.',               
    'Xlate Clear', '', '', '', 'A command line was removed.',              
  ];
    let NWParser=(disabled:bool=false){
      let allLogs = CommonSecurityLog
      | where not(disabled)
      | where DeviceVendor == "Cisco" and DeviceProduct == "ASA";
      let all_106001_alike = allLogs
      | where DeviceEventClassID in ("106001", "106006", "106015", "106016", "106021", "106022") 
      | parse Message with * " interface " DstInterfaceName;
      let all_106010_alike = allLogs
      | where DeviceEventClassID in ("106010", "106014")
      | parse Message with * " src "  SrcInterfaceName ":" * " dst " DstInterfaceName ":" *;
      let all_106018 = allLogs
      | where DeviceEventClassID == "106018"
      | parse Message with * "list " NetworkRuleName:string " " *;
      let all_106023 = allLogs
      | where DeviceEventClassID == "106023" and not(Message contains "protocol 41") and isnotempty(SourceIP)
      | parse Message with * " src "  SrcInterfaceName ":" * " dst " DstInterfaceName ":" * ' by access-group "' NetworkRuleName '" '  *;
      let all_106023_unparsed = allLogs
      | where DeviceEventClassID == "106023" and isempty(SourceIP) and not(Message contains "protocol 41")
      | extend parsedData = extract_all(@'%ASA-\d-\d+:\s*(\w+)\s+(\w+)\s+src\s+(\S+):(\d+.\d+.\d+.\d+)\/(\d+)\s*(\(\S+\)|\S+)*\s+dst\s+(\S+):(\d+.\d+.\d+.\d+)\/(\d+)\s*([(\S+\s+)]+|\S+)*\s*by\s+access-group\s*"(\S+)"',Message)[0]
            | extend 
              DeviceAction = coalesce(DeviceAction, tostring(parsedData[0])),
              Protocol = coalesce(Protocol, tostring(parsedData[1])),
              SrcInterfaceName = tostring(parsedData[2]),
              SrcIpAddr = coalesce(SourceIP, tostring(parsedData[3])),
              SrcPortNumber = coalesce(SourcePort, toint(parsedData[4])),
              SrcUsername = replace_string(replace_string(tostring(parsedData[5]), ")", ""), "(", ""),
              DstInterfaceName = tostring(parsedData[6]),
              DstIpAddr = coalesce(DestinationIP, tostring(parsedData[7])),
              DstPortNumber = coalesce(DestinationPort, toint(parsedData[8])),
              DstUsername = replace_string(replace_string(tostring(parsedData[9]), ")", ""), "(", ""),
              NetworkRuleName = tostring(parsedData[10])
      | extend 
              SrcUsernameType = iif(isnotempty(SrcUsername),"Windows",""),
              DstUsernameType = iif(isnotempty(DstUsername),"Windows",""),
              SimplifiedDeviceAction = DeviceAction
      | project-away parsedData;
      let all_106023_41 = allLogs
      | where DeviceEventClassID == "106023" and Message contains "protocol 41"
      | parse Message with * ": " Action " " ProtocolFromLog " src " SrcInterfaceName ":" SrcIpAddr " dst " DstInterfaceName ":" DstIpAddr ' by access-group ' NetworkRuleName ' '  *
      | extend Protocol = case(isnotempty(Protocol), Protocol,
                              ProtocolFromLog endswith "41", "41",
                              ""),
              NetworkRuleName = replace_string(NetworkRuleName,'"',''),
              DeviceAction = trim_start(@"\s*",Action),
              SimplifiedDeviceAction = trim_start(@"\s*",Action)
      | project-away ProtocolFromLog, Action;
      let all_302013_302015 = allLogs
      | where DeviceEventClassID in ("302013","302015")
      | parse Message with * ":  " DeviceAction " " NetworkDirection " " Protocol " connection " NetworkSessionId " for " SrcInterfaceName ":" SrcIpAddr "/" SrcPortNumber:int " (" SrcNatIpAddr "/" SrcNatPortNumber:int ")" SrcUsername "to " DstInterfaceName ":" DstIpAddr "/" DstPortNumber:int " (" DstNatIpAddr "/" DstNatPortNumber:int ")" DstUsername
      | extend SrcUsername = replace_string(replace_string(SrcUsername,"(",""),")",""),
               DstUsername = replace_string(replace_string(DstUsername,"(",""),")",""),
               NetworkDirection = case(NetworkDirection == "inbound", "Inbound",
                                       NetworkDirection == "outbound", "Outbound",
                                       NetworkDirection)
      | extend 
              SrcUsernameType = iif(isnotempty(SrcUsername),"Windows",""),
              DstUsernameType = iif(isnotempty(DstUsername),"Windows",""),
              SimplifiedDeviceAction = DeviceAction,
              SessionId = NetworkSessionId;
      let all_302014_302016 = allLogs
      | where DeviceEventClassID in ("302014", "302016")
      | extend parsedData = extract_all(@"%ASA-\d-\d+:\s*(\w+)\s+(\w+)\s+connection\s+(\d+)\s+for\s+(\S+):(\d+.\d+.\d+.\d+)\/(\d+)\s*(\(\S+\)|\S+)*\s+to\s+(\S+):(\d+.\d+.\d+.\d+)\/(\d+)\s*([(\S+\s+)]+|\S+)*\s*[Dd]uration\s+(\d+:\d+:\d+)\s+bytes\s+(\d+)\s*([\S+\s*]+)*",Message)[0]
    | extend reasonParsed = extract_all(@"$|\((\S+)\)|([\S+\s*]+)\s+from+\s+\S+\s+(\(\S+\)|\S+)$|([\S+\s*]+)\s+from+\s+\S+$|([\S+\s*]+)$",tostring(parsedData[13]))[0]
      | extend 
              DeviceAction = coalesce(DeviceAction, tostring(parsedData[0])),
              Protocol = coalesce(Protocol, tostring(parsedData[1])),
              NetworkSessionId = tostring(parsedData[2]),
              SrcInterfaceName = tostring(parsedData[3]),
              SrcIpAddr = coalesce(SourceIP, tostring(parsedData[4])),
              SrcPortNumber = coalesce(SourcePort, toint(parsedData[5])),
              SrcUsername = replace_string(replace_string(tostring(parsedData[6]), ")", ""), "(", ""),
              DstInterfaceName = tostring(parsedData[7]),
              DstIpAddr = coalesce(DestinationIP, tostring(parsedData[8])),
              DstPortNumber = coalesce(DestinationPort, toint(parsedData[9])),
              DstUsername = coalesce(replace_string(replace_string(tostring(parsedData[10]), ")", ""), "(", ""), tostring(reasonParsed[0]), replace_string(replace_string(tostring(reasonParsed[2]), ")", ""), "(", "")),
              NetworkDuration = toint(24 * 60 * totimespan(parsedData[11]) / time(1s)),
              DstBytes = tolong(parsedData[12]),
              Reason = coalesce(tostring(reasonParsed[1]), tostring(reasonParsed[3]), tostring(reasonParsed[4]))
      | lookup EventResultMapping on Reason
      | extend 
              SrcUsernameType = iif(isnotempty(SrcUsername),"Windows",""),
              DstUsernameType = iif(isnotempty(DstUsername),"Windows",""),
              SimplifiedDeviceAction = DeviceAction,
              SessionId = NetworkSessionId,
              EventOriginalResultDetails = iif(isnotempty(EventOriginalResultDetails), strcat(Reason, " - ", EventOriginalResultDetails), EventOriginalResultDetails)
      | project-away parsedData, reasonParsed, Reason;
      let all_302020_302021 = allLogs
      | where DeviceEventClassID in ("302020","302021")
      | extend SrcUsername = tostring(extract_all(@"\((\S+)\)",Message)[0])      
      | extend SrcUsernameType = iif(isnotempty(SrcUsername),"Windows","");
      let all_7_series = allLogs
      | where DeviceEventClassID in ("710002","710003","710004","710005")
      | parse Message with * " to " DstInterfaceName ":" *;
      let remainingLogs = allLogs
      | where DeviceEventClassID in ("106002", "106007", "106012", "106013", "106017", "106020", "106100");
      let ExternalInterface = _ASIM_GetWatchlistRaw("NetworkAddresses")
                                | extend WatchlistItem = parse_json(WatchlistItem)
                                | where WatchlistItem.Tags has "External"
                                | distinct tostring(WatchlistItem["Range Name"]);
      union isfuzzy=true all_106001_alike, all_106010_alike, all_106018, all_106023, all_106023_unparsed, all_106023_41,  all_302013_302015, all_302014_302016, all_302020_302021, all_7_series, remainingLogs
      | extend 
              EventStartTime = TimeGenerated,
              EventEndTime = TimeGenerated,
              EventVendor = "Cisco",
              EventProduct = "ASA",
              EventCount = toint(1),
              EventType = "NetworkSession",
              EventSchema = "NetworkSession",
              EventSchemaVersion = "0.2.3",
              EventProductVersion = DeviceVersion,
              EventOriginalSubType = DeviceEventClassID,
              EventSeverity = LogSeverity,
              EventOriginalSeverity = OriginalLogSeverity,
              DvcOriginalAction = DeviceAction,
              DvcAction = case(SimplifiedDeviceAction in ("Teardown","Built"), "",
                              SimplifiedDeviceAction),
              EventMessage = Message,
              Dvc = Computer,
              DstPortNumber = coalesce(DstPortNumber, DestinationPort),
              SrcPortNumber = coalesce(SrcPortNumber, SourcePort),
              DstIpAddr = coalesce(DstIpAddr, DestinationIP),
              SrcIpAddr = coalesce(SrcIpAddr, SourceIP),
              NetworkRuleName = coalesce(NetworkRuleName, DeviceCustomString2)
      | extend 
              NetworkDirection = case(isnotempty(CommunicationDirection), CommunicationDirection,
                                      DstInterfaceName in (ExternalInterface), "Outbound",
                                      SrcInterfaceName in (ExternalInterface), "Inbound",
                                      SrcInterfaceName !in (ExternalInterface) and DstInterfaceName !in (ExternalInterface), "Local",
                                      ""),
              NetworkProtocol = case(isnotempty(Protocol), toupper(Protocol),
                                    toint(Protocol) == "41", "IPv6",
                                    toint(Protocol) == "47", "GRE",
                                    ""),
              EventResult = case(isnotempty(EventResult), EventResult,
                                DvcAction == "Allow", "Success",
                                "Failure"),
              Src = SrcIpAddr,
              Dst = DstIpAddr,
              Duration = NetworkDuration,
              IpAddr = SrcIpAddr,
              Rule = NetworkRuleName,
              User = DstUsername
      | project-away Activity, AdditionalExtensions, ApplicationProtocol, CommunicationDirection, Computer, Destination*, Device*, EndTime, ExternalID, File*, Flex*, IndicatorThreatType, LogSeverity, Malicious*, Message, Old*, OriginalLogSeverity, Process*, Protocol, ReceiptTime, ReceivedBytes, Remote*, Report*, Request*, SentBytes, SimplifiedDeviceAction, Source*, StartTime, TenantId, ThreatConfidence, ThreatDescription, ThreatSeverity
      };
      NWParser(disabled)