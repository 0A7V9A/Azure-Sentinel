id: 48607a29-a26a-4abf-8078-a06dbdd174a4
name: Possible contact with a domain generated by a DGA
description: |
  'Identifies contacts with domains names in CommonSecurityLog that might have been generated by a Domain Generation Algorithm (DGA). DGAs can be used
  by malware to generate rendezvous points that are difficult to predict in advance. This detection uses the Alexa Top 1 million domain names to build a model
  of what normal domains look like. It uses this to identify domains that may have been randomly generated by an algorithm.
  The triThreshold is set to 500 - increase this to report on domains that are less likely to have been randomly generated, decrease it for more likely.
  The start time and end time look back over 6 hours of data and the dgaLengthThreshold is set to 8 - meaning domains whose length is 8 or more are reported.'
severity: Medium
requiredDataConnectors:
  - connectorId: Zscaler
    dataTypes:
      - CommonSecurityLog
  - connectorId: Barracuda
    dataTypes:
      - CommonSecurityLog
  - connectorId: CEF
    dataTypes:
      - CommonSecurityLog
  - connectorId: CheckPoint
    dataTypes:
      - CommonSecurityLog
  - connectorId: CiscoASA
    dataTypes:
      - CommonSecurityLog
  - connectorId: F5
    dataTypes:
      - CommonSecurityLog
  - connectorId: Fortinet
    dataTypes:
      - CommonSecurityLog
  - connectorId: PaloAltoNetworks
    dataTypes:
      - CommonSecurityLog
queryFrequency: 6h
queryPeriod: 6h
triggerOperator: gt
triggerThreshold: 0
tactics:
  - Command and Control
relevantTechniques:
  - T1483
query: |

    let triThreshold = 500;
    let startTime = 6h;
    let endTime = 0h;
    let dgaLengthThreshold = 8;
    // fetch the alexa top 1M domains
    let top1M =
    (externaldata (Position:int, Domain:string) 
     [@"http://s3-us-west-1.amazonaws.com/umbrella-static/top-1m.csv.zip"]
     with (format="csv", zipPattern="*.csv"));
    // extract tri grams that are above our threshold - i.e. are common
    let triBaseline = 
    top1M
     | extend Domain = tolower(extract("([^.]*).{0,7}$", 1, Domain))
     | extend AllTriGrams = array_concat(extract_all("(...)", Domain), extract_all("(...)", substring(Domain, 1)), extract_all("(...)", substring(Domain, 2)))
     | mvexpand Trigram=AllTriGrams
     | summarize triCount=count() by tostring(Trigram)
     | sort by triCount desc
     | where triCount > triThreshold
     | distinct Trigram;
    // collect domain information from common security log, filter and extract the DGA candidate
    let allDataSummarized = 
    CommonSecurityLog
    | where TimeGenerated > ago(startTime)
    | where TimeGenerated < ago(endTime)
    | where isnotempty(DestinationHostName)
    | project Name=tolower(DestinationHostName), SourceIP, DestinationIP, DataSource=DeviceVendor
    | summarize count() by Name, SourceIP, DestinationIP, DataSource
    | where Name contains "."
    | where Name !has ".home"
    | where Name !has ".lan"
    | extend DGADomain = extract("([^.]*).{0,7}$", 1, Name)
    | where strlen(DGADomain) > dgaLengthThreshold
    // throw out domains with number in them
    | where DGADomain matches regex "^[A-Za-z]{0,}$"
    | project DGADomain, Name, SourceIP, DestinationIP, DataSource;
    // extract the tri grams from summarized data
    let extractedTris = allDataSummarized 
    | extend AllTriGrams = array_concat(extract_all("(...)", DGADomain), extract_all("(...)", substring(DGADomain, 1)), extract_all("(...)", substring(DGADomain, 2)));
    // find domains that have repeating tri's and/or >=3 repeating letters
    let invalidTris =
    extractedTris
    | mvexpand AllTriGrams
    | summarize count() by tostring(AllTriGrams), Name, DGADomain, SourceIP, DestinationIP, DataSource
    | where count_ > 1
    | distinct DGADomain;
    // throw them out using an anti join
    let nonRepeatingTris =
    extractedTris
    | join kind=leftanti
        (
            invalidTris
        ) on DGADomain;
    // find domains that have a common tri in the baseline
    let domainsToExclude =
    nonRepeatingTris
    | mvexpand AllTriGrams
    | extend Trigram = tostring(AllTriGrams)
    | summarize count() by Trigram, DGADomain
    | join kind=inner
       (
          triBaseline
       )on Trigram
    | distinct DGADomain;
    // throw them out using an anti join
    let dataWithRareTris =
    nonRepeatingTris
    | join kind=leftanti
        (
            domainsToExclude
        ) on DGADomain;
    // throw out domains that feature in the top 1M
    dataWithRareTris
    | join kind=leftanti
    (
        top1M
        | extend Name = Domain
        | project Name
    ) on Name
    | project Name, DGADomain, SourceIP, DestinationIP, DataSource